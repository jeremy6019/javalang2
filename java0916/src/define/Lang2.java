package define;

public class Lang2 {
/*
	   ** 프로그래밍 언어에서 작업 단위 
	   메소드(작업 ) < 클래스(설계도)와 객체(실제 사용) < 패키지(배포 단위) 
	   => 검색의 결과는 패키지가 아니고 클래스로 나오는 경우가 많습니다.  
	   => 요즘 나오는 프로그래밍 언어는 패키지 단위로 다운로드나 설치하는 방법을 알아야 하고 필요한 작업을 수행해 줄 수 있는 
	        클래스를 잘 찾아야 합니다. 
	        클래스를 가지고 메소드를 어떤 방법으로활용해야 하는 지 기본문법을 정확하게 알아둘 필요가 있습니다. 
	      
	      1. java.lang.System 
	       => 시스템 설정과 관련된 클래스 
	       => 생성자가 없는 클래스 
           => java에서 property는 이름(문자열만 가능)과 값을 쌍으로 갖는 자료구조 
                프로퍼티는 환경설정에 사용하는 자료구조 
                지역화(언어나 국가 설정에 따라서 다르게 보이는 문자열이나 이미지 등)에 많이 이용하고 설정내용을 파일에 적어두는 용도로
                사용. 순수 java application보다는 java web application에서 많이 이용 
                개발환경과 실행환경에서 달라지는 속성들은 프로퍼티나 외부 데이터베이스를 이용하는 것을 권장  
          => 환경변수: 시스템의 설정과 관련된  변수들 
		       path:명령어를 입력했을때 명령어를 찾는 위치 설정 
		       path에 등록된 디렉토리에서 먼저 찾습니다. 
		       windows에서는 직접 추가해야 하는 경우가 많지만 mac은 자주 사용하는 프로그램은 자동 등록 
		       
		  => get,set Property로 프로퍼티를 설정하거나 읽어 올 수 있습니다.
		  => get,setenv로 환경변수를 설정하거나 읽어 올 수 있습니다. 
		  
		  => 설치된 자바의 버전 확인: java.version이라는 프로퍼티를 이용 
		  
		  => static long currentTimeMillis() 이 메소드는 1970년 1월1일 자정(epoch time)으로 지나온 시간을 1/1000초 단위의 정수로
		      리턴해 주는 메소드 입니다. 
		      1/1000000000초 단위로 리턴해 주는 nanotime()도 있는데 PC에서는 일반적으로 1/50초 아래 단위는 감지를 거의 해내지 
		      못하기 때문에 잘 사용하지 않음 
		      어떤 작업이 얼마나 걸리는지 확인하고자 하면 작업 시작 전에 메소드를 호출하고 작업 종료 후에 메소드를 호출해서 2개의 차이를 
		      구하면 됩니다
		      
		  => static void exit(int status): 시스템을 종료하는 메소드 
			  매개변수로 정수를 대입하는 데 이 메소드 대입된 정수는 운영체제에게 왜 종료되었는지 알려주는 코드 
			  0이면 정상 종료이고 그 이외의 양수는 에러 코드 입니다.
			  에러 코드에 따라 운영체제가 작업을 수행합니다. 
			  
		   => Garbage Collection: 자바에서 	heap(데이터가 실제 저장되는 영역)메모리 정리를 해주는 개체 
		        자바에서 생성된 객체의 메모리 정리는 객체를 가리키고 있는 변수가 없으면 정리 대상이 됩니다. 
		        시스템이 메모리 부족이나 일정시간 동안 아무런 작업이 없으면 정리를 합니다. 
		        System.gc() -> System.runFinalization()을 호출하면 바로 정리를 시작합니다. 
		        안드로이드나 서버환경에서는 이 메소드를 호출하는 것을 금기시합니다. 
		        안드로이드는 안드로이드가 알아서 메모리 정리도 하고 프로그램 종료도 합니다. 
		        Windows나 Mac은 운영제체가 프로그램을 졸료하는 것이 아니고 사용자나 개발자의 코드가 프로그램을 종료합니다. 
		        직접 생성한 객체의 메모리 정리를 하고자 할 때는 변수에 null을 대입하면 됩니다. 
		                 	     
	     2. 생성자가 없는 클래스 
	     => interface 나 abstract class인 경우 - 객체 생성을 할 수 없기 때문에 생성자가 필요없음 
	     => 모든 메소드가 static이어서 객체 생성이 필요없기 때문에 - 생성자가 private으로 만들어져 있음 
	     => static이 아닌 메소드가 있는 경우는  Builder 클래스(팩토리 메소드 패턴)나 자신의 static메소드 중에 객체를 리턴해 주는 
	     (싱클톤 패턴)메소드가 있음 
	     
	     3.Class 
	     => 클래스에 대한 정보를 가지는 클래스 
	     => 생성자를 이용해서 객체를 생성하지 않습니다. 
	     => 다른 객체의 getClass()를 이용해서 객체를 생성합니다. 
	     이렇게 만들어진 Class객체를 가지고 getName을 호출하면 클래스 이름을 문자열로 리턴받습니다. 
	     getSuperClass() 를 호출하면 Super클래스의 Class객체가 생성됩니다. 
	     => static Class forName(String className) throws ClassNotfoundEception 
	     className에 해당하는 클래스의 객체를 리턴하고 메모리에 로드하는 메소드로 존재하지 않는 클래스 이름을 사용하면 
	     ClassNotFoundException이 발생합니다. 
	     데이터베이스 연동 클래스들이 메모리에 자동으로 로드되지 않을때 이 메소드를 이용해서 강제로 메모리에 로드를 시킵니다. 
	     이 메소드는 사용하지 않아도 되는 경우가 있습니다. 
	     
	    4. java.lang.Math 
	    =>수락과 관련된 메소드를 소유한 클래스: javascript의 Math가 이클래스를 기반으로 만들어졌습니다. 
	    => 모든 메소드가 static이라서 객체를 생성할 필요가 없어서 생성자가 	private입니다. 
	    => 이클래스는 운영체제별로 다르게 동작합니다,. 
	    운영체제 별로 method의 수행결과가 달라질 수 있습니다. 
	    => 이에 대한 대안으로 StrictMath를 제시합니다. 
	    StrictMath는 math보다 연산속도가 느립니다. 
	    
	    5. java.lang.Runtime 
	    => 실행과 관련된 메소드를 소유한 클래스 
	    => 모든 메소드가 static이 아닌데 생성자가 보이지를 않습니다. 
	    이런 경우에는 제일 먼저 static메소드 중에서 자기 자신을 리턴하는 메소드가 있는지 확인  
	    static Runtime getRuntime()으로 객체를 생성합니다. 
	    => Process exec(string command): command에 대입된 명령어를 실행  
	    Process exec(string command, String arg): arg(파일경로)를 가지고 command(프로그램이름)를 실행 
	    Process exec(string command, String[] arg): 여러개의 파일을 가지고 command를 실행 
	     
	     => 파일 경로 작성시 주의사항 
	     windows는 디렉토리 기호가 역슬래시(\ - 운영체제에 따라서 원표시 기호로 보이기도 합니다.)여서 역슬래시를 2번 이용해야만 
	     역슬래스 1개가 만들어 집니다, 
	     나머지  모든 운영체제는 디렉토리 기호가 슬래시(/)입니다. 
	     1) 절대경로: 루트로부터의 전체 경로 입니다. 
	     
	     2) 상대 경로: 현재 위치로 부터의 경로입니다.
	     ./ :현재 디렉토리 
	     ../ :부모 디렉토리  
	    
	     3) 경로를 설정할 때 절대 경로를 이용하게 되면 시스템이 변경되거나 다른 컴퓨터에서 실행할 때 실행이 안될 수 있습니다.
	     다른 컴퓨터에서도 실행해야 하는 경우라면 상대 경로를 이용해야 합니다.   
	     
	    
	    !!! ** java.lang.String 
	    => 문자열과 관련된 클래스 
	    => 변하지 않는 문자열 저장에 이용 
	    1. 객체 생성 o
	    1)문자열 상수를 바로 대입해서 생성 
	    String ? = "문자열"; 
	    
	    2) 문자열 사웃를 생성자에 대입해서 생성 
	    String ? = new String("문자열"); 
	    
	    3) 문자열에 해당하는 byte배열과 인코딩방식을 이용해서 생성 o 
	    String ? = new String(문자열에 해당하는  byte[], Charset 인코딩 방식); 
	     
	    2.주요 메소드와 연산자 
	    1)+연산자: 문자열이나 다른 종류의 데이터와 +연산을 하게되면 다른 곳에 복사해서 연산한 후 결과를 리턴 
		    문자열 상수는 메모리 할당을 static영역에 하기 때문에 한 번 할당을 받으면 소멸되지 않습니다. 
		    문자열의 +연산은 금기시 되어 있습니다. 
	    
	      => 2)번과 3)번은 코딩테스트에서 중요한 메소드 
	      요즈음은 언어에 상관없이 코딩테스트에 응시 
	      C언어와 동일한 문제를 풀때는 아래 2개의 메소드만 사용할 수 있도록 제한하는 경우가 있습니다. 
	     
	     2) int length(): 글자수를 리턴해주는 메소드 
	     3) char charAt(int index):인덱스 번째에 해당하는 문자를 리턴해주는 메소드 
	     
	     4) 문자 코드값
	     => char는 문자 자료형이지만 실제로는 문자에 해당하는 코드값을 저장합니다,. 
	     출력을 할때 %c 또는 char를 출력하면 문자코드에 해당하는 문자를 찾아서 출력합니다 
	     숫자'0'은 48에서 시작 
	     대문자'A'는 65에서 시작 
	     소문자'a'는 97에서 시작 
	     소문자가 대문자보다 32가 더 큽니다. 
	     
	       =>한글(영문과 숫자이외의 문자)은 2byte(16bit) 코드로 만들어 집니다. 
	       이때 한글 각각의 글자를 어떤 값으로 저장 할 것인가 하는 문제가 encoding입니다. 
	       운영체제에서는 ms가 사용하는 cp949와 다른 운영체제가 사용하는 utf-8이 있습니다.
	       인터넷에서는 euc-kr 과 utf-8이 있습니다. 
	       utf-8은 전세계 모든 글자를 표현할 수 있지만 cp949나 euc-kr은 영문자와 숫자 그리고 한글만 표현이 가능합니다. 
	       최근에는 utf-8은 표준으로 취급합니다. 
	       
	       5)String toUpperCase(): 영문은 모두 대문자로 변경해서 리턴 
	       6)String toLowerCase(): 영문은 모두 소문자로 변경해서 리턴 
	       7) String trim(): 앞 뒤의 공백을 제거하고 리턴 
	       
	       => 인터넷에서 검색어나 ID는 대소문자 구분을 하지않는 경우가 많습니다. 
	       앞 뒤의 공백도 제거하고 사용하는 경우가 많습니다. 
	       영문을 다룰 때는 대소문자 구분을 할 것인지 아닌지를 결정해서 사용해야 합니다. 
	       대소문자 구분을 하지 않을 거라면 데이터를 저장할 때 대문자나 소문자로 변경해서 저장하고 이를 이용할 때도 대문자나 
	       소문자로 변경해서 이용해야 합니다. 
	       
	       => 다른 제한이 없다면 toUpperCase나 toLowerCase를 이용해서 대소문자로 변경하면 되는데 알고리즘 테스트에서는 
	       length나 charAt만 사용하도록 하는 경우가 있으므로 이를 구현해 보는 것이 좋습니다. 
	       
	       8) boolean equals(String other):other에 저장된 문자열이 동일한 지 판단해서 리턴해 주는 메소드 
	       9) int compareTo(String other): other와 비교해서 자신의 문자열이 크면 양수 같으면0 작으면 음수를 리턴해 주는 메소드
	       첫번째 글자부터 순서대로 비교하고 문자가 없으면 0으로 간주 
	       "Hello".compareTo("hello"): -1 
	       "Hello".compareTo("Hello"): 0 
	       "Hello".compareTo("Hello w"): -1
	       "Hello".compareTo("Good"): 1 
	       
	       10) boolean equalsIgnoreCase(String other): 대소문자 구분하지 않고 동일성 여부를 리턴 
	       
	       11) String[] split(String regexp): 괄호 안의 문자열로 구분해서 문자열 배열을 만들어주는 메소드 
	       String x = "Hello.World";
	       String[] result = x.split(".");
	       for(String temp:result){
	           System.out.println(temp);
	       }
	       
	       Hello
	       World 
	       12) int indexOf(String str): str이 존재하는 위치를 리턴해주는데 없으면 음수 
	            int lastIndexOf(String str): 뒤에서부터 찾아서 리턴해주는데 없으면 음수 
	      
	       13)static String format("서식", 데이터): 서식에 맞춰서 데이터를 추가한 후 문자열로 리턴하는 메소드 
	            System.out.printf는 문자열을 출력하고 format를 문자열을 만들어 줍니다. 
	           안드로이드와 같은 GUI프로그램들은 숫자를 화면에 직접 출력하지 못합니다. 
	           숫자를 화면에 출력하려면 문자열로 만들어서 출력을 합니다. 
	           여러 개의 데이터를 가지고 문자열을 만들때 +로 결합을 해도 되지만 이렇게 하면 메모리 낭비가 발생합니다.
	           모든 객체는 toString()을 호출하면 문자열로 변환이 가능합니다. 
	       
	       14)byte[] getBytes(인코딩방식): 인코딩방식에 따른 메모리 값을 바이트배열로 리턴해주는 메소드 
	       => 인코딩은 문자열을 메모리에 어덯게 저장하느냐의 문제 
	            디코딩은 메모리에 저장된 값을 가지고 문자열을 어떻게 만들 것이냐 하는 문제 
	       => 서로 다른 시스템에서 만들어진 파일이나 통신을 할 때는 인코딩문제를 고려해야 합니다. 
		       윈도우즈는 cp949가 기본 인코딩방식이고 맥은 utf-8이 기본 인코딩 방식입니다. 
		       맥에서 작성한 파일에 한ㄷ글이 있는 경우 윈도우즈에서 깨져서 읽어지게 됩니다. 
		       윈도우즈에 만든 파일에 한글이 있는 경우 맥에서 읽으면 깨지게 됩니다. 
		       클라이언트는 윈도우즈가 많아 보이지만 서버는 윈도우즈가 적게 사용됩니다. 
	       =>웹주소의 경우는 String	클래스의 메소드를 이용하지 않고 java.net.URLencoder의encode메소드나 URLDecoder의 
	           decode메소드를 이용합니다.
	           웹주소의 경우는 한글이 포함된 경우 인코딩을 하지 않으면 주소로 인식하지 못합니다.
	           
	      
	      **StringBuilder와 StringBuffer 클래스
	      => String은 변하지 않는 문자열을 저장하고 StringBuilser와 StringBuffer는 변할 수 있는 문자열을 저장합니다. 
	      => 차이점은 StringBuilder는 멀티 스레드에 안전하지 않고 StringBuffer는 멀티스레드에 안전 (safe)합니다.
	      멀티 스레드에 안전하다는 것은 사용을 하기 전에 다른 스레드가 사용을 하고 있으면 대기 했다가 나중에 작업을 수행하고 
	      멀티스레드에 안전하지 않다는 것은 사용을 하기 전에 확인하지 않고 바로 사용한다는 것입니다. 
	      최근에는 멀티 스레드에 대한 안전은 다른 방법을 이용해서 직접 하도록 권장하기 때문에 StringBuilder를 사용하기를 권장하빈다.
	      이렇게 이전에 사용하던 것이 현재 상황에 맞지 않은 경우 java에서 Legacy라고 하던가 deprecated되었다고 메세지를 작성합니다.  
	       
	       1.StringBuilder와 String 사이의 변환 
	       1)String을 가지고 StringBuilder만들기 
	       new StringBuilder(string str) 
	       2)StringBuilder객체를 가지고 String 마들기 
	       StringBuilder객체.tostring()
	       
	       2. StringBuilder의 주요 메소드 
	       void append(String str)
	       =>현재 있는 문자열에 str을 이어붙이는 메소드 
	       => 다른 곳에 복사하는 것이 아니고 현재 문자열에 이어 붙입니다. 
	       
	       3. 이 클래스를 사용할 때 주의할 점은 이 클래스는 객체를 생성할 때 여분의 공간을 가지고 객체를 만듭니다 
	            사용이 끝나면 메모리 정리를 해주는 것이 좋습니다. 
	       
	       * 시간날때 풀어보기 
	       
	       - 염기서열 
	       다음 문자열에서 GCCG가 있는 문자열의 시작위치를 전부 출력 
	       단 한번 나온 부분은 중첩해서 비교하면 안됩니다. 
	       
	       String msg = " GCCGCCGAHDNCGCCGGG";
	       0, 12 가 출력 
	       => indexOf 나 lastIndexOf의 사용법을 확인해서 해결: document를 읽어보고 사용법을 확인한 후 사용  
	       
	       => length() 와 charAt(int idx)만을 가지고 해결 
	       
	       - 아나그램인지 확인
		       아나그램은 내부 구성은 같고 위치만 다른 문자열을 아나그램이라고 합니다. 
		       eros의 아나그램으로는 rose가 있습니다. 
		       문자열 입력받아서 	eros의 아나그램인지 확인 
		       입력한 문자열이 rose이면 아나그램이라고 출력하고 roes이면 아나그램이 아니라고 출력 
	       
	        
	       
	       
	         
	         
	   
	  */
}
